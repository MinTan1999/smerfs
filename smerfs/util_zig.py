"""
Utility for building Ziggurat for the normal distribution

"""
from __future__ import print_function

import numpy as np
from scipy.special import erf
from scipy.optimize import bisect
from numpy import pi

def _num_seg(r_fin):
    """
    Find the number of segments it would take to build the Ziggurat
    """

    # normalisation of double guassian phi(x) = sqrt(2/pi)*exp(-0.5*x*x)
    dn = np.sqrt(2/pi) 
    
    # final bin (contains tail)
    y = [dn*np.exp(-0.5*r_fin*r_fin)]
    r = [r_fin]
    dA = (1-erf(r[0]/np.sqrt(2))) + r[0] * y[0]

    # Mean chance of being in tail where checked (outside Ziggurat)
    p_check = 1.0 # have to do a check when we are in the tail

    # loop until we have covered RHS of double Gaussian
    while True:
        y.append(y[-1] + dA/r[-1])

        if y[-1]>dn:
            r.append(0.0)
            p_check += 1 # definitely need to check against curve
            break
        
        r.append(np.sqrt(-2*np.log(y[-1]/dn)))
        p_check += (r[-2]-r[-1])/r[-2]

    # number of segments required to cover the guassian (approx)
    n_seg = (len(y)-1) + (dn-y[-2])/(y[-1]-y[-2])

    # average chance that we have to test against curve:
    p_check /= n_seg

    return n_seg, dA, p_check

def build_zig(r_fin, n_seg):

    # normalisation of double guassian phi(x) = sqrt(2/pi)*exp(-0.5*x*x)
    dn = np.sqrt(2/pi) 
    
    # final bin (contains tail)
    y = [dn*np.exp(-0.5*r_fin*r_fin)]
    r = [r_fin]
    a_tail = 1-erf(r[0]/np.sqrt(2))
    dA = a_tail + r[0] * y[0]

    # estimate of tail using exponentials (matched gradient at r_tail)
    exp_tail = y[0]/r_fin
    ratio = a_tail/exp_tail
    print('Tail fraction P(r>r_fin) = %.4f%%'%(100.0*a_tail))    
    print('Fraction of Gaussian in the exponential fit to the tail %.3f%%'%(100.0*ratio))

    contains = [dA] # Final bin is filled

    # Mean chance of being in tail where checked (outside Ziggurat)
    p_check = 1-r[0]*y[0]/dA # (1-erf(r[0]/np.sqrt(2)))/dA # have to do a check when we are in the tail

    # loop until we have covered RHS of double Gaussian
    for i in range(n_seg-2):
        y.append(y[-1] + dA/r[-1])

        r.append(np.sqrt(-2*np.log(y[-1]/dn)))
        fill = r[-1]*(dA/r[-2]) + (erf(r[-2]/np.sqrt(2)) - erf(r[-1]/np.sqrt(2))) - (r[-2]-r[-1])*y[-2]
        contains.append(fill)

        p_check += (r[-2]-r[-1])/r[-2]


    # Final segment
    p_check += 1 # definitely need to check against curve
    dA_last = r[-1]*(dn-y[-1])

    fill = erf(r[-1]/np.sqrt(2)) - r[-1]*y[-1]
    contains.append(fill)
    
    # Error on last area
    dA_err = (dA_last - dA)/dA

    # Av. prob. of checking against curve
    p_check *= 1.0/n_seg

    print('Actual area over sample area = %.3f%%'%(100.0/(dA*n_seg)))
    print('Per segment average = %.3f%%'%(100.0*np.mean(contains)/dA))
    print('Per segment loss = [', ', '.join('%.3f%%'%(100.0*(1-f/dA)) for f in contains),']')

    # 23 bit integers used for random 0-1
    int23 = 0x007fffff
    
    print('// The following constants were generated by the python script in smerfs/random.py\n')

    print('static const float log32 = %.7ff, // ln 1<<32\n  tail = %.9ff, inv_tail = %.9ff; // Tail\n'%(np.log(1<<32), r_fin, 1.0/r_fin))


    print('// Integers to test if you are in the block')
    # r0/r1 per segment (i.e the chance that you are in the block part, not the curve
    r_frac_seg = [x0/x1 for x0,x1 in zip(r[1:],r[:-1])] + [0] # always have to check first seg
    # Also on first seg (furthest right), fraction is r[0]y[0]/dA
    r_frac_seg = [r[0]*y[0]/dA] + r_frac_seg
    
    print('static const uint32_t in_block[%d] = {'%len(r_frac_seg), ','.join(hex(int(x*int23)) for x in r_frac_seg),'};\n')
    
    print('// 23-bit integer to float')
    r_conv = ['%.6ef'%(r[0]/r_frac_seg[0]/int23)] + ['%.6ef'%(x0/int23) for x0 in r]
    print('static const float to_float[%d] = {'%len(r_conv), ','.join(r_conv),'};\n')
    y_add_last = y + [dn]
    print('// exp(-0.5 x*x) for x in the ziggurat steps')
    print('static const float y[%d] = {'%len(y), ','.join('%.8ef'%(x/dn) for x in y),'};\n')
    print('// diff(exp(-0.5 x*x))/(1<<32) for x in the ziggurat steps')
    print('static const float y_seg[%d] = {'%(len(y_add_last)-1)+ ', '.join('%.8ef'%(x/dn/(1<<32)) for x in np.diff(y_add_last)) +'};')
    # 1st box multiple so correct prob. to be in tail
    p_tail0 = 1 - r[0]*y[0] / dA
    dmin = r[0] 

    return p_check, dA_err

    
def build_x(n):
    """
    n - number of rectangles

    Use bisection search to find Ziggurat edges
    """

    # First need to guess r0 for equal area

    a0 = 1.0/n
    # guess r, sqrt(2/pi)*r*exp(-0.5*r*r) = a0
    r_guess = 3.442619855899 # Known result for n_seg = 128 
#    r_guess = np.sqrt(-np.log(a0*a0*np.pi*0.5)/r_guess)


#    r_left, r_r
    print('R_guess %.3f'%r_guess)
    print('Num segments', _num_seg(r_guess))
    
    n_seg = lambda r : _num_seg(r)[0] - n

    r_n = bisect(n_seg, 1e-8,4.5)
    print('For n=%d, found r_fin=%.13f'%(n,r_n))

    p_check, dA_err = build_zig(r_n, n)

    print('Rel. error on last area', dA_err)
    print('Probability that you will hit tail segment = 1/%d = %.5f'%(n, 1.0/n))
    print('Prob. that you will have to test against curve %.5f%%'%(100.0*p_check))


if __name__=='__main__':
    build_x(256)




